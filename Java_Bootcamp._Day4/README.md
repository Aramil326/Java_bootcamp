Threads

Сегодня мы узнали, как использовать базовые механизмы многопоточности в Java.

# Содержание

1. [Exercise 00 – Egg, Hen... or Human?](https://github.com/Aramil326/Java_bootcamp/blob/master/Java_Bootcamp._Day4/README.md#exercise-00--egg-hen-or-human-%D0%B4%D0%B8%D1%80%D0%B5%D0%BA%D1%82%D0%BE%D1%80%D0%B8%D1%8F-%D0%B7%D0%B0%D0%B4%D0%B0%D0%BD%D0%B8%D1%8F)
2. [Exercise 01 – Egg, Hen, Egg, Hen...](https://github.com/Aramil326/Java_bootcamp/blob/master/Java_Bootcamp._Day4/README.md#exercise-01--egg-hen-egg-hen-%D0%B4%D0%B8%D1%80%D0%B5%D0%BA%D1%82%D0%BE%D1%80%D0%B8%D1%8F-%D0%B7%D0%B0%D0%B4%D0%B0%D0%BD%D0%B8%D1%8F)
3. [Exercise 02 – Real Multithreading](https://github.com/Aramil326/Java_bootcamp/blob/master/Java_Bootcamp._Day4/README.md#exercise-02--real-multithreading-%D0%B4%D0%B8%D1%80%D0%B5%D0%BA%D1%82%D0%BE%D1%80%D0%B8%D1%8F-%D0%B7%D0%B0%D0%B4%D0%B0%D0%BD%D0%B8%D1%8F)
4. [Exercise 03 – Too Many Threads...](https://github.com/Aramil326/Java_bootcamp/blob/master/Java_Bootcamp._Day4/README.md#exercise-03--too-many-threads-%D0%B4%D0%B8%D1%80%D0%B5%D0%BA%D1%82%D0%BE%D1%80%D0%B8%D1%8F-%D0%B7%D0%B0%D0%B4%D0%B0%D0%BD%D0%B8%D1%8F)

## Exercise 00 – Egg, Hen... or Human? ([директория задания](src/ex00))

| Exercise 00: Egg, Hen... or Human? |                           |
|------------------------------------|---------------------------|
| Директория сдачи                   | 	ex00                     |
| Файлы сдачи                 <br/>  | 	*.java                   |
| **Разрешено использовать:**        |                           |
| Types and their methods:           | 	Object, Thread, Runnable |

Chicken or egg

Истина рождается в споре — давайте предположим, что каждая ветка дает свой ответ. Верна та нить, за которой последнее
слово.

Вам необходимо реализовать работу двух потоков. Каждый из них должен показать свой ответ несколько раз, например, 50:

```
$ java Program --count=50
Egg
Hen
Hen
Hen
...
Egg
```

В этом случае яичная нить побеждает. Однако программа также содержит основной поток. Внутри потока выполняется метод
public static void main(String args[]). Нам нужен этот поток для отображения всех своих ответов в конце выполнения
программы. Таким образом, окончательный вариант выглядит следующим образом:

```
$ java Program --count=50
Egg
Hen
Hen
...
Egg
Hen
...
Human
...
...
Human
```

Это означает, что программа выводит Human сообщение 50 раз, которое печатает основной поток.

## Exercise 01 – Egg, Hen, Egg, Hen... ([директория задания](src/ex01))

| Exercise 00: Egg, Hen, Egg, Hen... |                          |
|------------------------------------|--------------------------|
| Директория сдачи                   | 	ex01                    |
| Файлы сдачи                        | *.java                   |
| **Разрешено использовать:**        |                          |
| Types and their methods:           | Object, Thread, Runnable |
| Keywords:                          | 	Synchronized            |

Давайте организуем спор. Теперь каждый поток может предоставить свой ответ только после того, как это сделает другой
поток. Предположим, что поток-яйцо всегда отвечает первым.

```
$ java Program --count=50
Egg
Hen
Egg
Hen
Egg
Hen
...
```

**Примечание**:<br>
Для решения данной задачи рекомендуем изучить принцип работы модели Производитель-Потребитель.

## Exercise 02 – Real Multithreading ([директория задания](src/ex02))

| Exercise 02: Real Multithreading |                          |
|----------------------------------|--------------------------|
| Директория сдачи                 | 	ex02                    |
| Файлы сдачи                      | *.java                   |
| **Разрешено использовать:**      |                          |
| Types and their methods:         | Object, Thread, Runnable |
| Keywords:                        | Synchronized             |

Попробуйте использовать многопоточность по прямому назначению: распределить вычисления по программе.

Предположим, существует массив целочисленных значений. Ваша цель — вычислить сумму элементов массива, используя
несколько потоков «суммирования». Каждый поток вычисляет определенный раздел внутри массива. Количество элементов в
каждом разделе постоянно, кроме последнего (его размер может отличаться в большую или меньшую сторону).

Массив должен генерироваться случайным образом каждый раз. Длина массива и количество потоков передаются в качестве
аргументов командной строки.

Чтобы убедиться в корректной работе программы, следует начать с вычисления суммы элементов массива стандартным методом.

Максимальное количество элементов массива — 2 000 000. Максимальное количество потоков не превышает текущего количества
элементов массива. Максимальное значение по модулю каждого элемента массива составляет 1000. Все данные гарантированно
действительны.

Пример работы программы (каждый элемент массива равен 1):

```
$ java Program --arraySize=13 --threadsCount=3
Sum: 13
Thread 1: from 0 to 4 sum is 5
Thread 2: from 5 to 9 sum is 5
Thread 3: from 10 to 12 sum is 3
Sum by threads: 13
```

**Примечание**:

- В приведенном выше примере размер последней секции суммирования, используемой третьим потоком, меньше, чем у других.
- Потоки могут непоследовательно выводить результаты работы

## Exercise 03 – Too Many Threads... ([директория задания](src/ex03))

| Exercise 02: Too Many Threads... |                           |
|----------------------------------|---------------------------|
| Директория сдачи	                | ex03                      |
| Файлы сдачи	                     | *.java                    |
| **Разрешено использовать:**      |                           |
| Types and their methods:         | 	Object, Thread, Runnable |
| Keywords:                        | 	Synchronized             |

Предположим, нам нужно скачать список файлов из сети. Некоторые файлы загружаются быстрее, а другие медленнее.

Для реализации этой функциональности мы, очевидно, можем использовать многопоточную загрузку, при которой каждый поток
загружает определенный файл. Но что делать, если файлов слишком много? Большое количество потоков не может выполняться
одновременно. Поэтому многие из них будут ждать.

Кроме того, мы должны иметь в виду, что непрерывное создание и завершение потоков — это очень дорогостоящая операция,
которой следует избегать. Разумнее запустить сразу N потоков и, когда любой из них завершит загрузку файла, он сможет
взять на себя следующий файл в очереди.

Нам необходимо создать файл files_urls.txt (имя файла должно быть явно указано в коде программы), в котором указывается
список URL-адресов файлов для скачивания, например:

```
1 https://i.pinimg.com/originals/11/19/2e/11192eba63f6f3aa591d3263fdb66bd5.jpg
2 https://pluspng.com/img-png/balloon-hd-png-balloons-png-hd-2750.png
3 https://i.pinimg.com/originals/db/a1/62/dba162603c71cac00d3548420c52bac6.png
4 https://pngimg.com/uploads/balloon/balloon_PNG4969.png
5 http://tldp.org/LDP/intro-linux/intro-linux.pdf
```

Пример работы программы:

```
$ java Program.java --threadsCount=3
Thread-1 start download file number 1
Thread-2 start download file number 2
Thread-1 finish download file number 1
Thread-1 start download file number 3
Thread-3 start download file number 4
Thread-1 finish download file number 3
Thread-2 finish download file number 2
Thread-1 start download file number 5
Thread-3 finish download file number 4
Thread-1 finish download file number 5
```

**Примечание**:

- Вывод, созданный реализованной программой, может отличаться от иллюстрации.
- Каждый файл загружается только один раз одним потоком.
- Программа может содержать «бесконечный цикл» без условия выхода (в этом случае программу можно завершить, прервав
  процесс).
