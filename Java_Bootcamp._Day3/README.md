IO, Files

Сегодня мы узнали, как использовать ввод/вывод на Java и реализовывать программы для управления файловой системой.

# Содержание

1. [Exercise 00 – File Signatures](https://github.com/Aramil326/Java_bootcamp/blob/master/Java_Bootcamp._Day3/README.md#exercise-00--file-signatures-%D0%B4%D0%B8%D1%80%D0%B5%D0%BA%D1%82%D0%BE%D1%80%D0%B8%D1%8F-%D0%B7%D0%B0%D0%B4%D0%B0%D0%BD%D0%B8%D1%8F)
2. [Exercise 01 – Words](https://github.com/Aramil326/Java_bootcamp/blob/master/Java_Bootcamp._Day3/README.md#exercise-01--words-%D0%B4%D0%B8%D1%80%D0%B5%D0%BA%D1%82%D0%BE%D1%80%D0%B8%D1%8F-%D0%B7%D0%B0%D0%B4%D0%B0%D0%BD%D0%B8%D1%8F)
3. [Exercise 02 – File Manager](https://github.com/Aramil326/Java_bootcamp/blob/master/Java_Bootcamp._Day3/README.md#exercise-02--file-manager-%D0%B4%D0%B8%D1%80%D0%B5%D0%BA%D1%82%D0%BE%D1%80%D0%B8%D1%8F-%D0%B7%D0%B0%D0%B4%D0%B0%D0%BD%D0%B8%D1%8F)

## Exercise 00 – File Signatures ([директория задания](src/ex00))

| Exercise 00: File Signatures |                                                                                                    |
|------------------------------|----------------------------------------------------------------------------------------------------|
| Каталог сдачи                | directory	ex00                                                                                     |
| Файлы для сдачи              | 	*.java, signatures.txt                                                                            |
| **Разрешенные конструкции**  |                                                                                                    |
| Recommended types            | Java Collections API (`List<T>`, `Map<K`, `V>`, etc.), InputStream, OutputStream, FileInputStream, |
| FileOutputStream             |                                                                                                    |

Вам необходимо реализовать приложение, которое принимает на вход файл signal.txt (его следует описать самостоятельно,
имя файла явно указано в коде программы). Он содержит список типов файлов и их соответствующие подписи в формате HEX.
Пример (необходимо соблюдать указанный формат этого файла):

```
PNG, 89 50 4E 47 0D 0A 1A 0A
GIF, 47 49 46 38 37 61
```

Во время выполнения ваша программа должна принимать полные пути к файлам на жестком диске и сохранять тип, которому
соответствует подпись файла. Результат выполнения программы должен быть записан в файл result.txt. Если подпись не может
быть определена, результат выполнения НЕ ОПРЕДЕЛЕН (никакая информация не должна быть записана в файл).

Пример работы программы:

```
$java Program
-> C:/Users/Admin/images.png
PROCESSED
-> C:/Users/Admin/Games/WoW.iso
PROCESSED
-> 42
```

Содержимое файла result.txt (в результате загружать этот файл не нужно):

```
PNG
GIF
```

**Примечание**:

- Мы можем точно определить тип контента, проанализировав подпись файла, поскольку расширение файла, содержащееся в
  имени (например, image.jpg), можно изменить, просто переименовав файл.
- Файл подписей должен содержать не менее 10 различных форматов для анализа.

## Exercise 01 – Words ([директория задания](src/ex01))

| Exercise 01: Words          |                               |
|-----------------------------|-------------------------------|
| Каталог сдачи directory	    | ex01                          |
| Файлы для сдачи             | 	*.java                       |
| **Разрешенные конструкции** |                               |
| Recommended types           | Java Collections API, Java IO |

Теперь вам нужно реализовать приложение, которое будет определять уровень сходства между текстами. Самый простой и
очевидный способ сделать это — проанализировать частоту встречаемости одних и тех же слов.

Предположим, что у нас есть два следующих текста:

```
1. aaa bba bba a ссс
2. bba a a a bb xxx
```

Создадим словарь, содержащий все слова в этих текстах:

```
a, aaa, bb, bba, ccc, xxx
```

Теперь создадим два вектора длиной, равной длине словаря. В i-й позиции каждого вектора отразим частоту встречаемости
i-го слова в нашем словаре в первом и последнем текстах:

```
A = (1, 1, 0, 2, 1, 0)
B = (3, 0, 1, 1, 0, 1)
```

Таким образом, каждый из этих векторов характеризует текст с точки зрения частоты встречаемости слов из нашего словаря.
Определим сходство векторов по следующей формуле:

![formula](misc/images/img.png)

Таким образом, величина сходства для этих векторов равна:

```
Numerator A. B = (1 * 3 + 1 * 0 + 0 * 1 + 2 * 1 + 1 * 0 + 0 * 1) = 5
Denominator ||A|| * ||B|| = sqrt(1 * 1 + 1 * 1 + 0 * 0 + 2  * 2 + 1 * 1 + 0 * 0) * sqrt(3 * 3 + 0 * 0 + 1 * 1 + 1 * 1  + 0 * 0 + 1 * 1) = sqrt(7) * sqrt(12) = 2.64 * 3.46 = 9.1
similarity = 5 / 9.1 = 0.54
```

Ваша цель — реализовать приложение, которое принимает два файла в качестве входных данных (оба файла передаются в
качестве аргументов командной строки) и отображает результат их сравнения сходства (косинусная мера).

Программа также создаст файл словарь.txt, содержащий словарь на основе этих файлов.

Пример работы программы:

```
$ java Program inputA.txt inputB.txt
Similarity = 0.54
```

**Примечание**:

1. Максимальный размер этих файлов составляет 10 МБ.
2. Файлы могут содержать небуквенные символы.

## Exercise 02 – File Manager ([директория задания](src/ex02))

| Exercise 02: File Manager   |                                                   |
|-----------------------------|---------------------------------------------------|
| Каталог сдачи directory     | 	ex02                                             |
| Файлы для сдачи             | 	*.java                                           |
| **Разрешенные конструкции** |                                                   |
| Recommended types           | Java Collections API, Java IO, Files, Paths, etc. |

Давайте реализуем утилиту для работы с файлами. Приложение должно отображать информацию о файлах, содержимом и размере
папок, а также обеспечивать функцию перемещения/переименования. По сути, приложение эмулирует командную строку
Unix-подобных систем.

Программа должна принимать в качестве аргумента абсолютный путь к папке, где мы начинаем работать, и поддерживать
следующие команды:

`mv` WHAT WHERE – позволяет перенести или переименовать файл, если WHERE содержит имя файла без пути.
`ls` – отображает текущее содержимое папки (имена и размеры файлов и подпапок в КБ).
`cd FOLDER_NAME` – изменяет текущий каталог

Предположим, на диске C:/ (или в корневом каталоге, в зависимости от ОС) имеется папка MAIN со следующей иерархией:

- MAIN
    + folder1
        * image.jpg
        * animation.gif
    + folder2

    * text.txt
    * Program.java

Пример работы программы для каталога MAIN:

```
$ java Program --current-folder=C:/MAIN
C:/MAIN
-> ls
folder1 60 KB
folder2 90 KB
-> cd folder1
C:/MAIN/folder1
-> ls
image.jpg 10 KB
animation.gif 50 KB
-> mv image.jpg image2.jpg
-> ls
image2.jpg 10 KB
animation.gif 50 KB
-> mv animation.gif ../folder2
-> ls
image2.jpg 10 KB
-> cd ../folder2
C:/MAIN/folder2
-> ls
text.txt 10 KB
Program.java 80 KB
animation.gif 50 KB
-> exit
```

**Примечание**:<br>
Функциональность программы следует протестировать, используя собственный набор файлов/папок.
